"""*
 * @file argconfig.py
 * @author osterhoutan (osterhoutan+scabbard@gmail.com)
 * @brief configures the argument parser for the scabbard python script
 * @date 2024-05-23
 * 
 *"""
 
from argparse import ArgumentParser
from typing import List

__all__ = ['ScabbardArgParser','parseScabbardArgs','printScabbardHelp']

ScabbardArgParser: ArgumentParser = ArgumentParser(
        prog="scabbard",
        usage="""
        Scabbard is a tool that allows you to track down data races that occur between a GPU and CPU 
          (GPU write and CPU read) that occur because of the new heterogenous memory models gpu code
          now enjoys.  It is currently only designed to work with AMDs Hip programming language.
          
        Using scabbard is a three step process:
          (1) build your code using scabbards instrumentation tool.
          (2) run your code using the scabbard trace tool.
          (3) analyse the trace file produced with the scabbard verify tool.
          
        Use:   <>-data-type  {}-optional   []-required   ...-multiple accepted
          $ scabbard [mode] -h 
          Use -h on a subprogram/mode to leran more on how to use it.
        """,
        epilog="""
        no support information yet provided. (TODO)
        """    
    )

_SubArgParser = ScabbardArgParser.add_subparsers(
        title='mode',
        description="""
        The mode in which you wish the scabbard interface to function.
        """,
        help="Choose the mode that correlates to your current step",
    )

InstrArgParser = _SubArgParser.add_parser('instr',
        # aliases=['build','instrument','instr','compile','link'
        #          'Build','Instrument','Instr','Compile','Link'
        #          'BUILD','INSTRUMENT','INSTR','COMPILE','LINK'],
        prog='instrument build',
        help="use this to launch your build process(es) so that instrumented binaries are produced. (FOR SINGLE FILE BUILDS ONLY)",
        usage="""
            <>-data-type  {}-optional   []-required   ...-multiple accepted
        
        $ scabbard instr {--meta-file=<file-path>} [build-tool-exe] {extra-build args}...  
        
        example:
          $ scabbard instr --meta-file=$(pwd)/proj-name.scabbard.meta make all -j 4
        """,
        epilog="""
        no support information yet provided. (TODO)
        """   
    )
InstrArgParser.set_defaults(mode='instr')

BuildArgParser = _SubArgParser.add_parser('build',
        # aliases=['build','instrument','instr','compile','link'
        #          'Build','Instrument','Instr','Compile','Link'
        #          'BUILD','INSTRUMENT','INSTR','COMPILE','LINK'],
        prog='build/compile',
        help="use this to launch your build process(es) that have already been configured to use the scabbard instrumenter",
        usage="""
            <>-data-type  {}-optional   []-required   ...-multiple accepted
        
        $ scabbard build {--meta-file=<file-path>} [build-tool-exe] {extra-build args}...  
        
        example:
          $ scabbard build --meta-file=$(pwd)/proj-name.scabbard.meta make all -j 1
        """,
        epilog="""
        no support information yet provided. (TODO)
        """   
    )
BuildArgParser.set_defaults(mode='build')

TraceArgParser = _SubArgParser.add_parser('trace',
        # aliases=['trace','run','launch','Trace','Run','Launch',"TRACE","RUN","LAUNCH"],
        prog='trace-runner',
        help="use this to launch an instrumented executable to produce a trace file",
        usage="""
                <>-data-type   {}-optional   []-required   ...-multiple accepted
        
        $ scabbard trace {--trace-file=<file-path>} [instrumented-exe] {extra-launch-args}...  
        
        example:
          $ scabbard trace --trace-file=$(pwd)/proj-name.scabbard.trace ./my-exe -my --extra="launch args"
        """,
        epilog="""
        no support information yet provided. (TODO)
        """  
    )
TraceArgParser.set_defaults(mode='trace')

VerifArgParser = _SubArgParser.add_parser('verif',
        # aliases=['verify','verif','analyse','analyze',
        #          'Verify','Verif','Analyze','Analyse',
        #          'VERIFY','VERIF','ANALYZE','ANALYSE'],
        prog='verifier',
        help="this tool uses the meta-file generated by the instrumenter and the trace file generated "
             "by the instrumented executable to analyse your code's run and report on data races "
             "and places where data races might occur in the future",
        usage="""
            <>-data-type  {}-optional   []-required  ...-multiple accepted
        
        $ scabbard verif [meta-file] [trace-file] 
        
        example:
          $ scabbard verif $(pwd)/proj-name.scabbard.meta $(pwd)/proj-name.scabbard.trace
        """,
        epilog="""
        no support information yet provided. (TODO)
        """ 
    )
VerifArgParser.set_defaults(mode='verif')

InstrArgParser.add_argument('--meta-file',
        nargs=1,
        default=None,
        metavar='<file-path>',
        required=False,
        help="filepath to where the metadata file to be generated will be written to (this is used by the verify step so remember it)"                           
    )
BuildArgParser.add_argument('--meta-file',
        nargs=1,
        default=None,
        metavar='<file-path>',
        required=False,
        help="filepath to where the metadata file to be generated will be written to (this is used by the verify step so remember it)"                           
    )
VerifArgParser.add_argument('meta_file',
        nargs=1,
        default=None,
        metavar='<meta-file-path>',
        help="filepath to where the metadata file generated during the instrumentation/build step"                           
    )


TraceArgParser.add_argument('--trace-file','-t','-o',
        nargs=1,
        default=None,
        metavar='<file-path>',
        required=False,
        help="filepath to where the trace file will be generated "
              "(remember this as it will be used in the verify step) "
              "[WARNING: this file can be large in size]"
    )
VerifArgParser.add_argument('trace_file',
        nargs=1,
        default=None,
        metavar='<trace-file-path>',
        help="filepath to where the trace file generated by the trace step (this file can be large in size)"                           
    )

def parseScabbardArgs(argv:List[str]) -> tuple:
    return ScabbardArgParser.parse_known_args(argv)


def printScabbardHelp() -> None:
    ScabbardArgParser.print_help()

# __all__ = ['ParsedArgs','parseArgs']


# @dataclass(repr=True,eq=False,order=False,unsafe_hash=True)
# class ParsedArgs:
#     mode: str | None
#     meta_file: Path | None
#     trace_file: Path | None
#     executable: Path | None
#     args: List[str] | None


# def _parseComplexModeArg(result:ParsedArgs, arg:str, argv: List[str]) -> None:
#     path = shutil.which(arg)


# def parseArgs(argv: List[str]) -> ParsedArgs:
#     result: ParsedArgs = ParsedArgs(None,None,None,None,None)
#     match str.lower(argv[1]):
#         case 'build' | 'instrument' | 'instr' | 'compile' | 'comp' | 'i' | 'b' | 'c':
#             result.mode = 'instr'
#         case 'run' | 'launch' | 'trace' | 'r' | 'l' | 't':
#             result.mode = 'run'
#         case 'verify' | 'verif' | 'ver' | 'analyse' | 'analyze' | 'anal' | 'v' | 'a':
#             result.mode = 'verif'
#         case 'make' | 'clang' | 'clang++' | 'hipcc' | 'ninja' | 'cc' | 'cpp':
#             result.mode = 'instr'
#             tmp = shutil.which(argv[1])
#             if tmp is not None:
#                 result.executable = Path(tmp)
#                 result.args = argv[2:] if len(argv)>=3 else None
#                 return result
#             else: 
#                 raise ArgumentError('mode',f"could not identify `{argv[1]}` as a scabbard mode or valid executable!")
#         case _:
#             _parseComplexModeArg(result, argv[1], argv[2:] if len(argv)>=3 else list())
    

 
 
 