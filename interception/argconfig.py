"""*
 * @file argconfig.py
 * @author osterhoutan (osterhoutan+scabbard@gmail.com)
 * @brief configures the argument parser for the scabbard python script
 * @date 2024-05-23
 * 
 *"""
 
from argparse import ArgumentParser
from typing import List 
import re, os

__all__ = ['ScabbardArgParser','parseScabbardArgs','printScabbardHelp', 'process_mem_limit']

ScabbardArgParser: ArgumentParser = ArgumentParser(
        prog="scabbard",
        usage="""
        Scabbard is a tool that allows you to track down data races that occur between a GPU and CPU 
          (GPU write and CPU read) that occur because of the new heterogenous memory models gpu code
          now enjoys.  It is currently only designed to work with AMDs Hip programming language.
          
        Using scabbard is a three step process:
          (1) build your code using scabbards instrumentation tool.
          (2) run your code using the scabbard trace tool.
          (3) analyse the trace file produced with the scabbard verify tool.
          
        Use:   <>-data-type  {}-optional   []-required   ...-multiple accepted
          $ scabbard [mode] -h 
          Use -h on a subprogram/mode to leran more on how to use it.
        """,
        epilog="""
        no support information yet provided. (TODO)
        """    
    )

_SubArgParser = ScabbardArgParser.add_subparsers(
        title='mode',
        description="""
        The mode in which you wish the scabbard interface to function.
        """,
        help="Choose the mode that correlates to your current step",
    )

InstrArgParser = _SubArgParser.add_parser('instr',
        # aliases=['build','instrument','instr','compile','link'
        #          'Build','Instrument','Instr','Compile','Link'
        #          'BUILD','INSTRUMENT','INSTR','COMPILE','LINK'],
        prog='instrument build',
        help="use this to launch your build process(es) so that instrumented binaries are produced. (FOR SINGLE FILE BUILDS ONLY)",
        usage="""
            <>-data-type  {}-optional   []-required   ...-multiple accepted
        
        $ scabbard instr {--meta-file=<file-path>} [build-tool-exe] {extra-build args}...  
        
        example:
          $ scabbard instr --meta-file=$(pwd)/proj-name.scabbard.meta make all -j 4
        """,
        epilog="""
        no support information yet provided. (TODO)
        """   
    )
InstrArgParser.set_defaults(mode='instr')

BuildArgParser = _SubArgParser.add_parser('build',
        # aliases=['build','instrument','instr','compile','link'
        #          'Build','Instrument','Instr','Compile','Link'
        #          'BUILD','INSTRUMENT','INSTR','COMPILE','LINK'],
        prog='build/compile',
        help="use this to launch your build process(es) that have already been configured to use the scabbard instrumenter",
        usage="""
            <>-data-type  {}-optional   []-required   ...-multiple accepted
        
        $ scabbard build {--meta-file=<file-path>} [build-tool-exe] {extra-build args}...  
        
        example:
          $ scabbard build --meta-file=$(pwd)/proj-name.scabbard.meta make all -j 1
        """,
        epilog="""
        no support information yet provided. (TODO)
        """   
    )
BuildArgParser.set_defaults(mode='build')

TraceArgParser = _SubArgParser.add_parser('trace',
        # aliases=['trace','run','launch','Trace','Run','Launch',"TRACE","RUN","LAUNCH"],
        prog='trace-runner',
        help="use this to launch an instrumented executable to produce a trace file",
        usage="""
                <>-data-type   {}-optional   []-required   ...-multiple accepted
        
        $ scabbard trace {--trace-file=<file-path>} [instrumented-exe] {extra-launch-args}...  
        
        example:
          $ scabbard trace --trace-file=$(pwd)/proj-name.scabbard.trace ./my-exe -my --extra="launch args"
        """,
        epilog="""
        no support information yet provided. (TODO)
        """  
    )
TraceArgParser.set_defaults(mode='trace')

VerifArgParser = _SubArgParser.add_parser('verif',
        # aliases=['verify','verif','analyse','analyze',
        #          'Verify','Verif','Analyze','Analyse',
        #          'VERIFY','VERIF','ANALYZE','ANALYSE'],
        prog='verifier',
        help="this tool uses the meta-file generated by the instrumenter and the trace file generated "
             "by the instrumented executable to analyse your code's run and report on data races "
             "and places where data races might occur in the future",
        usage="""
            <>-data-type  {}-optional   []-required  ...-multiple accepted
        
        $ scabbard verif [meta-file] [trace-file] 
        
        example:
          $ scabbard verif $(pwd)/proj-name.scabbard.meta $(pwd)/proj-name.scabbard.trace
        """,
        epilog="""
        no support information yet provided. (TODO)
        """ 
    )
VerifArgParser.set_defaults(mode='verif')

VerifArgParser.add_argument('--mem-limit','-m',
        nargs=1,
        default=None,
        type=str,
        metavar='<size-in-M/k/G>',
        help="the max amount of memory you want the verifier to use (does not count overhead, so keep at max 75\% system)"
    )
VerifArgParser.add_argument('--threads','-t',
        nargs=1,
        default=None,
        type=int,
        metavar='<#-threads>',
        help="how many threads you want to use when processing trace files in bulk"
    )
# VerifArgParser.add_argument('--chunk-size','-c',
#         nargs=1,
#         default=None,
#         type=int,
#         metavar='<#-threads>',
#         help="how many threads you want to use when processing trace files in bulk"
#     )

InstrArgParser.add_argument('--meta-file',
        nargs=1,
        default=None,
        metavar='<file-path>',
        required=False,
        help="filepath to where the metadata file to be generated will be written to (this is used by the verify step so remember it)"                           
    )
BuildArgParser.add_argument('--meta-file',
        nargs=1,
        default=None,
        metavar='<file-path>',
        required=False,
        help="filepath to where the metadata file to be generated will be written to (this is used by the verify step so remember it)"                           
    )
VerifArgParser.add_argument('meta_file',
        nargs=1,
        default=None,
        metavar='<meta-file-path>',
        help="filepath to where the metadata file generated during the instrumentation/build step"                           
    )


TraceArgParser.add_argument('--trace-file','-t','-o',
        nargs=1,
        default=None,
        metavar='<file-path>',
        required=False,
        help="filepath to where the trace file will be generated "
              "(remember this as it will be used in the verify step) "
              "[WARNING: this file can be large in size]"
    )
VerifArgParser.add_argument('trace_file',
        nargs='+',
        default=None,
        type=str,
        metavar='<trace-file-path>...',
        help="filepath to where the trace file generated by the trace step (this file can be large in size)"                           
    )

def parseScabbardArgs(argv:List[str]) -> tuple:
    return ScabbardArgParser.parse_known_args(argv)


def printScabbardHelp() -> None:
    ScabbardArgParser.print_help()


def process_mem_limit(arg:str) -> int|float:
    try:
        m = re.match(r'(\d+(?:\.\d*)?)([GgMmKk])?(?:\w*)?', arg)
        if m:
            val = float(m.group(0))
            multiplier = 1
            if m.group(1) is not None:
                match m.group(1).lower():
                    case _:
                        multiplier = 1
                    case 'k':
                        multiplier = 10**3
                    case 'm':
                        multiplier = 10**6
                    case 'g':
                        multiplier = 10**9
            return val * multiplier
        print("ARGUMENT ERROR: `--mem-limit/-m` argument must be a positive value grater than 0 with an optional unit designation of G/M/k")
        exit(-1)
    except Exception as ex:
        print(f"ARGUMENT ERROR: invalid input for `--mem-limit/-m` argument\n\t{ex!s}")
        exit(-1)

def process_chunk_size(arg:str) -> int:
    try:
        val = int(arg)
        if val > 0:
            print("ARGUMENT ERROR: `--chunk-size/-c` argument must be a positive integer grater than 0")
            exit(-1)
        return val
    except Exception as ex:
        print(f"ARGUMENT ERROR: failed to parse the `--chunk-size/-c` argument to an integer value!\n\t{ex!s}")
        exit(-1)

def process_threads(arg:str) -> int:
    try:
        val = int(arg)
        if not (0 < val <= os.cpu_count()):
            print(f"ARGUMENT ERROR: `--threads/-t` argument must be a positive integer no grater than the number of available HW threads on your system ({os.cpu_count()})")
            exit(-1)
        return val
    except Exception as ex:
        print(f"ARGUMENT ERROR: failed to parse the `--threads/-t` argument to an integer value!\n\t{ex!s}")
        exit(-1)

# __all__ = ['ParsedArgs','parseArgs']


# @dataclass(repr=True,eq=False,order=False,unsafe_hash=True)
# class ParsedArgs:
#     mode: str | None
#     meta_file: Path | None
#     trace_file: Path | None
#     executable: Path | None
#     args: List[str] | None


# def _parseComplexModeArg(result:ParsedArgs, arg:str, argv: List[str]) -> None:
#     path = shutil.which(arg)


# def parseArgs(argv: List[str]) -> ParsedArgs:
#     result: ParsedArgs = ParsedArgs(None,None,None,None,None)
#     match str.lower(argv[1]):
#         case 'build' | 'instrument' | 'instr' | 'compile' | 'comp' | 'i' | 'b' | 'c':
#             result.mode = 'instr'
#         case 'run' | 'launch' | 'trace' | 'r' | 'l' | 't':
#             result.mode = 'run'
#         case 'verify' | 'verif' | 'ver' | 'analyse' | 'analyze' | 'anal' | 'v' | 'a':
#             result.mode = 'verif'
#         case 'make' | 'clang' | 'clang++' | 'hipcc' | 'ninja' | 'cc' | 'cpp':
#             result.mode = 'instr'
#             tmp = shutil.which(argv[1])
#             if tmp is not None:
#                 result.executable = Path(tmp)
#                 result.args = argv[2:] if len(argv)>=3 else None
#                 return result
#             else: 
#                 raise ArgumentError('mode',f"could not identify `{argv[1]}` as a scabbard mode or valid executable!")
#         case _:
#             _parseComplexModeArg(result, argv[1], argv[2:] if len(argv)>=3 else list())
    

 
 
 